[{"title":"PyTorch入门","path":"/2023/01/20/PyTorch入门/","content":"深度学习的入门部分 环境准备部分Python 3.9AnacondaCuda 10.0开发工具: PyCharm 巨尼玛狗的部分，Pytorch下载巨慢我TM真是服了国内的傻逼服务器和镜像，你妈的下东西是真tm慢啊 用管理员身份打开cmd添加配置: conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 同时添加几个第三方镜像配置更新一手，没吊用了，挂个梯子硬下吧查看已经安装的相关镜像源: conda config --show 清除所有额外安装的镜像源 conda config --remove-key channels 记得要挂美爹的节点 配置PyCharm在pycharm中创建项目时，记得Python编辑器要选conda中的，不然找不到那个傻逼torch验证pytorch是否安装好: import torchprint(torch.__version__)print(&#x27;gpu:&#x27;,torch.cuda.is_available()) 线性模型示例： 线性模型 $ \\widehat{y} &#x3D; x * \\omega $Training Loss(Error): $ loss &#x3D; (\\widehat{y} - y)^2 &#x3D; (x * \\omega - y)^2 $–&gt;Mean Square Error:$cost &#x3D; \\frac{1}{N}\\sum_{n&#x3D;1}^N (\\widehat{y_{n}} - y_n)^2 $ 普通的计算方式import numpy as npimport matplotlib.pyplot as pltx_data = [1.0,2.0,3.0]y_data = [2.0,4.0,6.0]def forward(x): return x * wdef loss(x,y): y_pred = forward(x) return (y_pred - y) * (y_pred - y) #(y_pred - y)^2w_list = []mse_list = []for w in np.arange(0.0,4.1,0.1): print(&#x27;w=&#x27;,w) l_sum = 0 for x_val,y_val in zip(x_data,y_data): y_pred_val = forward(x_val) # 预测的值（以当前循环中的w为准） loss_val = loss(x_val,y_val) # 当前w为准下，y的偏差的平方（这里面会再将上面一行函数调用一遍，参数也相同） l_sum += loss_val print(&#x27;\\t&#x27;,x_val,y_val,y_pred_val,loss_val) print(&#x27;MSE=&#x27;,l_sum/3) w_list.append(w) mse_list.append(l_sum/3)plt.plot(w_list,mse_list)plt.ylabel(&#x27;Loss&#x27;)plt.xlabel(&#x27;w&#x27;)plt.show() 梯度下降算法Gradient Descent 核心在于下降,在上面的题目中，绘制出的图像是一个y轴代表损失值、x轴代表w值的图像，则损失值越少，就代表当前的w越精确，所以要在函数图像上下降到y损失值最低的那个点。这就是下降 梯度梯度部分，就是上面图像中每个点处代表的斜率$ \\frac{\\sigma cost}{\\sigma \\omega} $,斜率大于0时，w加上斜率损失值会增大，斜率小于0时也是，所以我们要用减去斜率的方式，也就是反向行走 $$w &#x3D; w -\\alpha \\frac{\\sigma cost}{\\sigma \\omega}$$其中$ \\alpha $代表学习率，相当于控制每一步要走多远同样用于解上面问题的代码: 梯度下降解法import numpy as npimport matplotlib.pyplot as pltx_data = [1.0,2.0,3.0]y_data = [2.0,4.0,6.0]e_list = []w_list = []w = 1.0 # 初始值# TODO 返回测试值def forward(x): return x * w# TODO 返回偏差值def cost(xs,ys): cost = 0 for x,y in zip(xs,ys): y_pred = forward(x) cost += (y - y_pred)**2 return cost/len(xs)# TODO 返回梯度值def gradient(xs,ys): grad = 0 for x,y in zip(xs,ys): y_pred = forward(x) grad += 2 * x * (y_pred - y) return grad/len(xs)print(&#x27;Predict(before training)&#x27;,4,forward(4))for epoch in range(100): cost_val = cost(x_data,y_data) grad_val = gradient(x_data,y_data) w -= 0.01 * grad_val w_list.append(w) e_list.append(epoch) print(&#x27;Epoch:&#x27;,epoch,&#x27;w=&#x27;,w,&#x27;loss=&#x27;,cost_val)print(&#x27;Predict (after training)&#x27;,4,forward(4))plt.plot(e_list,w_list)plt.xlabel(&#x27;epoch&#x27;)plt.ylabel(&#x27;w&#x27;)plt.show() 随机梯度下降算法Stochastic Gradient Descent(SGD) 最基本的随机梯度下降，每次更新参数只使用1个样本本题中就是在每一轮中，对每一个样本都进行参数的更新此算法不利于并行计算，因为每次进行参数的更新之后，下一个样本就要用到这个更新后的参数，而不会等到下一轮。 SGD代码# TODO 随机梯度下降算法import matplotlib.pyplot as pltx_data = [1.0,2.0,3.0]y_data = [2.0,4.0,6.0]w = 1.0e_list = []w_list = []def forward(x): return x * wdef loss(x,y): y_pred = forward(x) return (y - y_pred)**2def gradient(x,y): return 2 * x * (x * w - y)print(&#x27;Predict(before training)&#x27;,4,forward(4))for epoch in range(100): for x,y in zip(x_data,y_data): grad_val = gradient(x,y) w -= 0.01 * grad_val print(&quot;\\tgrad:&quot;,x,y,grad_val) l = loss(x,y) w_list.append(w) e_list.append(epoch) print(&quot;progress:&quot;,epoch,&quot;w=&quot;,w,&quot;loss=&quot;,l)print(&quot;Predict (after training)&quot;,4,forward(4))plt.plot(e_list,w_list)plt.xlabel(&#x27;epoch&#x27;)plt.ylabel(&#x27;w&#x27;)plt.show()","tags":["pytorch","深度学习"],"categories":["程序","深度学习"]},{"title":"git与idea的学习","path":"/2023/01/17/Git/","content":"Git与Github的学习以及结合idea的应用 Git基础Git工作机制:工作区(写代码) -&gt;(git add)-&gt;暂存区-&gt;(git commit)-&gt;本地库-&gt;(push)-&gt;远程库 Git 常用命令git config --global user.name 用户名 设置用户签名git config --global user.email 邮箱 设置用户签名git init 初始化本地库git status 查看本地库状态git add 文件名 添加到暂存区git commit -m &quot;日志信息&quot; 文件名 提交到本地库git reflog 查看历史记录git reset --hard 版本号 版本穿梭 设定完用户名和邮箱后，可以在对应用户的文件夹下找到文件.gitconfig,在此文件中看到自己的设置；也可以在gitBash中用命令$ cat ~/.gitconfig来查看 12806@lxafate MINGW64 ~$ cat ~/.gitconfig[user] email = useforgit@gmail.com name = lxaDust 注意这里设置的用户签名和将来登录GitHub的账号没有任何关系 git初始化本地库选择一个空的文件夹，右键打开git bash用命令git init,初始化这个文件夹为一个git的库之后也可以用git status查看这个库的状态: 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track) On branch master表示这个项目在master分支下No commits yet 表示还没有提交文件nothing to commit (create/copy files and use &quot;git add&quot; to track)表示还没有要提交的文件(也就是缓存区里也没有文件) 创建文件后再查看状态，会多出一行内容: Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) hello.txt 这里表示文件夹内有文件没有被追踪（就是刚创建的文件),提示我们用git add命令去追踪 add之后再查看状态: Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: hello.txt 表示文件已经被添加到暂存区中了这里括号里提示可以将文件从暂存区中删除，删除后本地文件夹中仍然有此文件，这个命令只是将文件从暂存区中删除。 提交本地库12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git commit -m &quot;first commit&quot; hello.txt[master (root-commit) 79ae43c] first commit 1 file changed, 6 insertions(+) create mode 100644 hello.txt 这时再查看状态: $ git statusOn branch masternothing to commit, working tree clean 查看日志查看精简日志: $ git reflog79ae43c (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (initial): first commit 查看详细日志: $ git logcommit 79ae43c0817f024765486a8370678aaf8eb8f357 (HEAD -&gt; master)Author: lxaDust &lt;useforgit@gmail.com&gt;Date: Tue Jan 17 10:14:11 2023 +0800 first commit 修改文件修改刚刚commit的文件的内容，再查看状态: $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 这里表示修改并没有被追踪再按照上面的命令执行一遍: 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git add hello.txt12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git commit -m &quot;second commit&quot; hello.txt[master 30023ad] second commit 1 file changed, 4 insertions(+), 4 deletions(-) 再查看日志可以看到记录简洁日志 $ git reflog30023ad (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit79ae43c HEAD@&#123;1&#125;: commit (initial): first commit 详细日志 $ git logcommit 30023adf1a92f36cd5498a978bce8c161bfa3463 (HEAD -&gt; master)Author: lxaDust &lt;useforgit@gmail.com&gt;Date: Tue Jan 17 10:29:51 2023 +0800 second commitcommit 79ae43c0817f024765486a8370678aaf8eb8f357Author: lxaDust &lt;useforgit@gmail.com&gt;Date: Tue Jan 17 10:14:11 2023 +0800 first commit 30023ad (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit这里指针指向第二个版本 版本穿梭git reset --hard 版本号用git reflog即可查看每个版本对应的简洁版版本号，用这个版本号即可回到对应版本 $ git reset --hard 30023adHEAD is now at 30023ad second commit Git的分支操作什么是分支？在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用） 分支的好处1、同时并行多个功能开发，提高开发效率；2、各个分支在开发过程中不会互相影响。 分支的操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 分支名 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 查看分支$ git branch -v* master 30023ad second commit 创建分支$ git branch hot-fix 再查看分支: $ git branch -v hot-fix 30023ad second commit* master 30023ad second commit 切换分支12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git checkout hot-fixSwitched to branch &#x27;hot-fix&#x27;12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (hot-fix)$ 修改分支就是修改当前分支的文件之后，再add,commit提交，commit之后切换到另一个分支，另一个分支下的文件不变。 合并分支git merge 分支名作用是将指定分支合并到当前分支上 $ git merge hot-fixUpdating 30023ad..3acb055Fast-forward hello.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 合并时产生冲突产生冲突的原因合并分支时，两个分支在同一个文件的同一位置有两套完全不同的修改，git无法替我们决定使用哪一个。必须人为决定新代码内容。 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git merge hot-fixAuto-merging hello.txtCONFLICT (content): Merge conflict in hello.txtAutomatic merge failed; fix conflicts and then commit the result.12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master|MERGING)$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: hello.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 这时查看冲突的文件内容: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADHello Git!master test=======Hello Git!hot-fix test&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD与=======之间是当前分支的修改，下面的内容是要合并过来的分支的修改。然后直接修改文件就行。修改完后，再将这个文件添加到暂存区、提交。 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master|MERGING)$ vim hello.txt12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master|MERGING)$ git add hello.txt12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master|MERGING)$ git commit -m &quot;merge hot-fix&quot;[master 6a229e0] merge hot-fix 注意！这里提交的时候不能带上文件名！ GitHub操作创建远程库直接在github上new一个库就行（言简意赅）。 远程仓库操作创建远程仓库别名可以先使用命令git remote -v查看当前所有远程地址的别名；用命令git remote add 别名 远程地址来为远程地址起一个别名，建议名字为仓库名。 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git remote -v12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git remote add git-demo https://github.com/lxaDust/git-demo.git12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-Space/git-demo (master)$ git remote -vgit-demo https://github.com/lxaDust/git-demo.git (fetch)git-demo https://github.com/lxaDust/git-demo.git (push) 推送本地库到远程库命令git push 别名 分支名 $ git push git-demo masterEnumerating objects: 27, done.Counting objects: 100% (27/27), done.Delta compression using up to 16 threadsCompressing objects: 100% (18/18), done.Writing objects: 100% (27/27), 1.98 KiB | 506.00 KiB/s, done.Total 27 (delta 7), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (7/7), done.To https://github.com/lxaDust/git-demo.git * [new branch] master -&gt; master 拉取远程库到本地库命令git pull 别名 远程分支名 注意:是远程分支名 $ git pull git-demo masterremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), 645 bytes | 35.00 KiB/s, done.From https://github.com/lxaDust/git-demo * branch master -&gt; FETCH_HEAD 6a229e0..80d7b27 master -&gt; git-demo/masterUpdating 6a229e0..80d7b27Fast-forward hello.txt | 1 + 1 file changed, 1 insertion(+) 克隆远程库到本地命令git clone 远程地址 克隆代码不需要账号 12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-bochi$ git clone https://github.com/lxaDust/git-demo.gitCloning into &#x27;git-demo&#x27;...remote: Enumerating objects: 30, done.remote: Counting objects: 100% (30/30), done.remote: Compressing objects: 100% (13/13), done.remote: Total 30 (delta 8), reused 26 (delta 7), pack-reused 0Receiving objects: 100% (30/30), done.Resolving deltas: 100% (8/8), done.12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-bochi$ cd git-demo/12806@lxafate MINGW64 /d/尚硅谷Git、GitHub、Gitee码云、GitLab（IDEA版本）/Git-bochi/git-demo (master)$ 克隆会做三件事: 拉取代码 初始化本地仓库 创建别名","tags":["兴趣","git","分版本"],"categories":["程序","闲余兴趣"]},{"title":"VSCode中的cpp配置","path":"/2023/01/15/VScode的cpp配置/","content":"VSCode更加轻便且功能很足，在这款软件上进行c++程序的编写会很省心 1,安装扩展在VSCode左侧的扩展栏中搜索c&#x2F;c++，安装对应的扩展 2,安装编译环境这里选择的是TDM-GCC，这里附上百度网盘的链接： 提取码:bwez 如果链接失效则可以直接去官网下载 记得在安装时要勾选gdb64 3,配置环境变量TDM-GCC安装完成后需要加入到系统的环境变量中在path下添加TDM-GCC文件下bin文件夹的位置，如： C:\\TDM-GCC-64\\bin 4,配置VSCode中的环境创建文件夹.vscode进入VSCode后选择打开一个文件夹，在这个文件夹下创建一个名为.vscode的文件夹，此文件夹用来存放配置文件 配置文件在.vscode文件夹下新建两个文件:launch.json,tasks.json,文件内容如下: tasks.json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [&#123; &quot;label&quot;: &quot;g++&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;problemMatcher&quot;: &#123; &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, &quot;$&#123;workspaceRoot&#125;&quot; ], &quot;pattern&quot;: &#123; &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 &#125; &#125;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 一定注意！miDebuggerPath这一条，一定要与TDM-GCC安装路径一致，且’&#39;要替换为’\\‘ launch.json&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,// 将要进行调试的程序的路径 &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，一般设置为false &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: true,// 调试时是否显示控制台窗口，一般设置为true显示控制台 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;F:\\\\Software\\\\TDM-GCC-64\\\\TDM-GCC-64\\\\bin\\\\gdb64.exe&quot;,// miDebugger的路径，注意这里要与MinGw的路径对应 &quot;preLaunchTask&quot;: &quot;g++&quot;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 5,编写c++程序现在即可编写c++程序了，新建文件，后缀为cpp,如果在写代码过程中，右下角出现让你安装东西的提示，点install安装即可，这里应该是会安装一个适配c++的代码高亮的插件，写起来会很舒服 按Ctrl+F5执行由于VSCode在执行完程序后会退出，所以要看结果的话还是建议右上角Debug，并且在末尾加上断点。","categories":["程序","配置"]},{"title":"博客进阶","path":"/2023/01/08/博客进阶/","content":"文章摘要卡片封面图片在文章列表页面或者其他位置上显示的文章摘要卡片上面的图片称之为【文章封面】要想图片全部显示，可以在front-matter中加入以下参数即可: cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red... 为了显示美观，建议topic和caption选择其一与headline搭配使用 横幅图片文章页面顶部区域可以显示长长的横幅图片，设置方法如下: banner: image_src 文档系统创建一个项目在blog/source/文件夹中创建一个wiki文件夹，在其中放入各个项目的文档，以2023_1_anime项目为例 blog/source/wiki/2023_1_anime/2023年1月新番.md 设置布局模板和项目名称: title: 2023年一月新番 #这是分页标题layout: wiki #使用wiki布局模板wiki: 2023_1_anime #这是项目名 完善项目信息在数据文件中创建项目文件(blog/source/_data_projects.yml) Stellar: name: Stellar title: Stellar - 每个人的独立博客 subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; tags: 博客主题 cover: true logo: src: /assets/wiki/stellar/icon.svg small: 112px large: 240px description: Stellar 是一个内置 wiki 系统的 hexo 主题，适合综合型站点使用。同时也拥有简约而精美的视觉设计和丰富的标签插件，帮助您简单从容地应对各种场合。 repo: xaoxuu/hexo-theme-stellar comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27; giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226 是否显示封面项目可以显示一个全屏封面，封面占据一个屏幕的高度，会居中一次显示项目的logo、标题、描述。开启项目封面方法如下: Stellar: cover: true logo: src: /assets/wiki/stellar/icon.svg small: 120px large: 240px 如果logo中已经包含了项目标题，可以这样设置不显示项目标题: Stellar: cover: [logo, description] 主题色支持HEX&amp;HSL表示颜色 style: color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 button: &#x27;hsl(192 98% 55%)&#x27; # 按钮颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色","categories":["博客","博客界面"]},{"title":"算法题目记录","path":"/2023/01/07/算法题目记录/","content":"算法学习过程中的刷题记录 DFS排列数字https://www.acwing.com/problem/content/844/题目位置 AC代码#include&lt;iostream&gt;const int N = 10;int n;int path[N];bool st[N];using namespace std;void dfs(int u)&#123; if(u==n) &#123; for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,path[i]); puts(&quot;&quot;); &#125; for(int i=1;i&lt;=n;i++) &#123; if(!st[i]) &#123; path[u] = i; st[i] = true; dfs(u+1); st[i] = false; &#125; &#125; &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(0); return 0;&#125; 记录没啥好记录的 n皇后https://www.acwing.com/activity/content/problem/content/906/题目位置 AC代码#include&lt;iostream&gt;using namespace std;const int N = 20;int n;char chess[N][N];bool col[N],dg[N],udg[N];void dfs(int u)&#123; if(u==n)&#123; for(int i=0;i&lt;n;i++)&#123; puts(chess[i]); &#125; puts(&quot;&quot;); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(!col[i]&amp;&amp;!dg[i+n-u]&amp;&amp;!udg[2*n-i-u-1])&#123; col[i] = dg[i+n-u] = udg[2*n-i-u-1] = true; chess[u][i] = &#x27;Q&#x27;; dfs(u+1); chess[u][i] = &#x27;.&#x27;; col[i] = dg[i+n-u] = udg[2*n-i-u-1] = false; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; chess[i][j] = &#x27;.&#x27;; &#125; &#125; dfs(0); return 0;&#125; 思路通过递归来进行dfs的搜索，搜索每一行，若发现当前位置可以放置皇后（if(!col[i]&amp;&amp;!dg[i+n-u]&amp;&amp;!udg[2*n-i-u-1])），那就标记此位置(col[i] = dg[i+n-u] = udg[2*n-i-u-1] = true;),再到下一行。 记录对角线和反对角线的规律可以看一下，就是分别从左下角和右下角走到对应位置所经过的格数+1 BFS走迷宫https://www.acwing.com/problem/content/description/846/题目位置 AC代码#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N = 110;int dx[4] = &#123;0,0,1,-1&#125;;int dy[4] = &#123;1,-1,0,0&#125;;int g[N][N];int d[N][N];queue&lt;PII&gt; q;int n,m;int bfs()&#123; int len = 0; memset(d,-1,sizeof d); d[1][1] = 0; while(!q.empty())&#123; PII temp = q.front(); q.pop(); // g[temp.first][temp.second] = 1; for(int i=0;i&lt;4;i++)&#123; int x = temp.first+dx[i]; int y = temp.second+dy[i]; if(0&lt;x&amp;&amp;x&lt;=n&amp;&amp;0&lt;y&amp;&amp;y&lt;=m&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]==-1)&#123; d[x][y] = d[temp.first][temp.second]+1; q.push(&#123;x,y&#125;); &#125; &#125; &#125; return d[n][m];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;g[i][j]; q.push(&#123;1,1&#125;); cout&lt;&lt;bfs()&lt;&lt;endl; return 0;&#125; 思路使用队列来存储，每次循环，取出队头的元素，遍历其能到达的位置，并将队头元素删去如果能到达的位置符合要求(0&lt;x&amp;&amp;x&lt;=n&amp;&amp;0&lt;y&amp;&amp;y&lt;=m&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]==-1)，那就将其位置代表的距离出发点的距离+1（d[x][y] = d[temp.first][temp.second]+1;）,之后再将此点加入队列中不断执行这个步骤，直到队列为空，所有能到达的点全都遍历了一遍为止，返回终点代表的距离即可。 记录因为是宽度优先搜索，所以在遍历到一个点时，如果d[x][y]!=-1，则说明在前面就已经到达了这个点，既然是在前面就已经到达了，就说明这个点现在记录的到出发点的距离本身就是最短的，所以无需更新。对于二元数对的自定义typedef pair&lt;int,int&gt; PII;统一修改数组的值memset(d,-1,sizeof d);,此函数头文件为&lt;cstring&gt;宽度优先搜索的基础是边的权重是1 八数码https://www.acwing.com/problem/content/847/题目位置 AC代码#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;int bfs(string start)&#123; string end = &quot;12345678x&quot;; unordered_map&lt;string,int&gt; d; d[start] = 0; queue&lt;string&gt; q; q.push(start); int dx[4] = &#123;0,0,1,-1&#125;; int dy[4] = &#123;1,-1,0,0&#125;; while(q.size())&#123; string state = q.front(); q.pop(); int distance = d[state]; if(state==end)return distance; int t = state.find(&#x27;x&#x27;); int x = t/3,y = t%3; for(int i=0;i&lt;4;i++)&#123; int a = x+dx[i],b = y+dy[i]; if(0&lt;=a&amp;&amp;a&lt;3&amp;&amp;0&lt;=b&amp;&amp;b&lt;3)&#123; swap(state[t],state[a*3+b]); if(!d.count(state))&#123; d[state] = distance+1; q.push(state); &#125; swap(state[t],state[a*3+b]); &#125; &#125; &#125; return -1;&#125;int main()&#123; string start; for(int i=0;i&lt;9;i++)&#123; char c; cin&gt;&gt;c; start += c; &#125; cout&lt;&lt;bfs(start)&lt;&lt;endl; return 0;&#125; 思路就是存储每一个状态(queue),每一个状态距离初始状态的距离用无序图存储(unordered_map),由于是bfs方法，所以如果一个状态在已经找到之后又出现，那么新出现的状态代表的距离一定不小于前面被找到之后的距离，所以可以舍弃（if(!d.count(state))）； 记录1、状态的表示，本题中3X3方格的状态表示使用string来表示2、状态转移，一个状态转向另一个状态的过程，状态的距离用map来进行存储；3、这种3X3方格中，字符x的位置可以用int t = state.find(&#x27;x&#x27;);int x = t/3,y = t%3;来表示","categories":["程序","ACM"]},{"title":"博客表达类标签测试","path":"/2023/01/07/博客表情测试/","content":"表情 使用格式: &#123;% emoji 爱你 %&#125;&#123;% emoji blobcat ablobcatrainbow %&#125;&#123;% emoji tieba 滑稽 %&#125;&#123;% emoji blobcat ablobcatattentionreverse %&#125; mark行内文本标记支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 默认 红 橙色 使用格式: &#123;% mark 默认 %&#125;&#123;% mark 红 color:red %&#125;&#123;% mark 橙色 color:orange %&#125; tag标签效果类似于mark标签，但是支持链接，更适合一批标签独占一行使用 Github Hexo BiliBili 使用格式: &#123;% tag Github https://github.com/lxaDust %&#125;&#123;% tag Hexo https://hexo.io/ %&#125;&#123;% tag BiliBili https://www.bilibili.com/ color:purple %&#125; 图片标签图片描述测试 语法格式: &#123;% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %&#125; 参数说明 src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: &#x27;#ffffff&#x27; # 图片区域背景颜色，16进制 使用格式: &#123;% image https://c2.im5i.com/2023/01/12/YrrUd.jpeg 图片描述测试 %&#125; 小尺寸图片优化宽度较小而高度较大的图片，可以设置宽、高、填充间距、背景色等对其布局进行优化，使得它在不同宽度的屏幕下都能获得不错的视觉体验 有底色的图片，可以填充图片底色 没有底色的图片，可以填充动态颜色，能够适配暗黑模式 使用格式: &#123;% image /assets/applewatch.png 有底色的图片，可以填充图片底色 width:200px padding:16px bg:white %&#125;&#123;% image /assets/星球.svg 没有底色的图片，可以填充动态颜色，能够适配暗黑模式 bg:var(--card) padding:16px %&#125; 支持Fancybox插件点击放大由于 Stellar 主题的插件具有按需加载的特性，所以 Fancybox 插件默认也是已经配置好了的，在任意 image 标签中增加 fancybox:true 参数即可为特定图片开启缩放功能。如果一个页面没有任何地方使用，则不会加载 Fancybox 插件。 点击放大 使用格式: &#123;% image https://hakaimg.com/i/2023/01/12/y08cd9.png 点击放大 fancybox:true%&#125; 如果您希望全站所有的 image 标签都开启此功能，可在主题配置文件中修改以下参数： ######## Tag Plugins ########tag_plugins: # &#123;% image %&#125; image: fancybox: true note备注块备注块测试(红色) 备注块测试(默认) 使用格式: &#123;% note 备注块测试(红色) color:red %&#125;&#123;% note 备注块测试(默认) %&#125; title: 标题（可选）content: 内容color: red/orange/yellow/green/cyan/blue/purple/light/dark/warning/error 具有标题的备注块这是&nbsp标题这是正文，这里可以随意使用 空格 使用格式: &#123;% note 这是&amp;nbsp标题 这是正文，这里可以随意使用 空格 %&#125; link链接卡片https://github.com/https://github.com/ https://www.bilibili.com/https://www.bilibili.com/ 使用格式: &#123;% link https://github.com/ %&#125;&#123;% link https://www.bilibili.com/ desc:true%&#125; 语法格式: 外链卡片标签的语法格式为： &#123;% link href [title] [icon:src] [desc:true/false] %&#125; 参数含义： href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述 copy复制行 使用格式: &#123;% copy curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy https://github.com/lxaDust %&#125; navbar导航栏文章内也可以插入一个导航栏： GitHubBiliBili 文本修饰标签集 这是密码标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 使用格式: - 这是&#123;% psw 密码%&#125;标签- 这是 &#123;% u 下划线 %&#125; 标签- 这是 &#123;% emp 着重号 %&#125; 标签- 这是 &#123;% wavy 波浪线 %&#125; 标签- 这是 &#123;% del 删除线 %&#125; 标签- 这是 &#123;% sup 上角标 color:red %&#125; 标签- 这是 &#123;% sub 下角标 %&#125; 标签- 这是 &#123;% kbd 键盘样式 %&#125; 标签，试一试：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125; quot引用适合居中且醒目的引用 Stellar 是最好用的主题 支持自定义引号: 热门话题 自定义引号素材在主题配置文件的tag_plugins.quot(就在_config.yml)中配置: tag_plugins: ... # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png 特别引用 此外，加上el:h2&#x2F;h3&#x2F;h4…可以作为标题使用","categories":["博客","博客界面"]},{"title":"博客容器类标签测试","path":"/2023/01/07/博客容器类标签测试/","content":"博客的容器类标签使用笔记 封面 ablock 普通块容器note 标签就是用 ablock 容器实现的，他们的样式是相同的: &#123;% ablock [title] [color:color] [child:codeblock/tabs] %&#125;...&#123;% endablock %&#125; 写法如下: Stellar v1.12.0因为原 noteblock 标签在升级到hexo 6.0 后跟官方库冲突了，官方一直没有解释原因，后不得不改名:noteblock -&gt; grid -&gt; border -&gt; ablock &#123;% ablock Stellar v1.12.0 color:warning %&#125;因为原 noteblock 标签在升级到hexo 6.0 后跟官方库冲突了，官方一直没有解释原因，后不得不改名:noteblock -&gt; grid -&gt; border -&gt; ablock&#123;% endablock %&#125; 彩色代码块设置child:codeblock并设置color:颜色枚举可以实现10中不同颜色的代码块，彩色代码块一般可以用在代码正确与错误的示范对比场景 ColorCodefunc test()&#123; //...&#125; 嵌套其他标签例如嵌套一个tabs标签 图文混排示例代码个人电脑作为办公设备时，我们该如何保护隐私 ?公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。&#123;% ablock child:tabs %&#125;&#123;% tabs %&#125;&lt;!-- tab 图文混排 --&gt;&#123;% image https://c2.im5i.com/2023/01/12/YrdLO.jpeg fancybox:true 个人电脑作为办公设备时，我们该如何保护隐私 ? %&#125;公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。&lt;!-- tab 示例代码 --&gt;code&#123;% endtabs %&#125;&#123;% endablock %&#125; folding 折叠容器折叠块标签的语法格式为: &#123;% folding title [child:codeblock][open:bool][color:color]%&#125;content&#123;% endfolding %&#125; 参数说明child:codeblock 是否是代码状态open:true/flasecolor: red/orange/yellow/green/cyan/blue/purple/light/dark 示例: 可折叠容器默认情况下open:false除了标题之外都会折叠进去 写法&#123;% folding 可折叠容器 %&#125;默认情况下`open:false`除了标题之外都会折叠进去&#123;% endfolding %&#125; folders多个折叠容器聚合样式相比folding简单一些，适用于多个折叠标签平铺显示的场景，例如题目列表: 题目1这是答案题目2这是答案题目3这是答案 实现代码&#123;% folders %&#125;&lt;!-- folder 题目1 --&gt;这是答案&lt;!-- folder 题目2 --&gt;这是答案&lt;!-- folder 题目3 --&gt;这是答案&#123;% endfolders %&#125; tabs 分栏容器这个标签移植自NexT主题,但是做了以下修改: 支持设置align:center来使内容居中 设置默认激活的标签方式为active:1而非.1(使用默认格式降低学习成本，且显式声明可读性更强) 不需要&lt;!-- endtab --&gt;来作为结束标识(因为 Stellar 会自动判断) 不需要tabs id来保证唯一性(因为 Stellar 会设置唯一标识) 不支持@icon方式设置图标(因为 Stellar 不再内置fontawesome图标库) 轮廓样式简化，可以搭配其他容器类标签嵌套使用。 演示效果示例代码图片代码块表格let x = 123print(&quot;Hello World&quot;) a b c a1 a2 a3 a2 b2 c2 &#123;% tabs active:1 align:center %&#125;&lt;!-- tab 演示效果 --&gt;&#123;% tabs active:2 align:center %&#125;&lt;!-- tab 图片 --&gt;&#123;% image /assets/p1.jpg width:300px fancybox:true %&#125;&lt;!-- tab 代码块 --&gt;\\```swiftlet x = 123print(&quot;Hello World&quot;)\\```&lt;!-- tab 表格 --&gt;| a | b | c || --- | --- | --- || a1 | a2 | a3 || a2 | b2 | c2 |&#123;% endtabs %&#125;&lt;!-- tab 示例代码 --&gt;&#123;% ablock child:codeblock color:black %&#125;code&#123;% endablock %&#125;&#123;% endtabs %&#125;","categories":["博客","博客界面"]},{"title":"ACM小知识点","path":"/2023/01/07/ACM小知识点，小模板记录/","content":"做算法题时的一些用的较少，但是在适用场合会非常有用的小方法。 ACM小知识点，小模板记录欧几里得算法求最大公约数：int gcd(int a,int b)&#123;\treturn b ? gcd(b,a%b):a;&#125; 最小公倍数的性质：[a,b] &#x3D; a*b&#x2F;(a,b) [a,b]为最小公倍数 (a,b)为最大公约数 cin和cout的加速有的地方不让用。 std::ios::sync_with_stdio(false);//消除输入输出缓存std::cin.tie(0);//解除cin与cout的绑定，加快速率 第二个好像可以不用，程序中只需要第一行就能大幅加快速度 还是用print和scanf吧，这个东西不太稳定 二元数对的自定义typedef pair&lt;int,int&gt; PII; 统一修改数组的值memset(d,-1,sizeof d); 头文件是:#include&lt;cstring&gt;","categories":["程序","ACM"]},{"title":"前端","path":"/2023/01/06/前端/","content":"前端的学习记录，多为零碎知识点 前端响应式布局： 能够适应 不同大小界面的布局。 CSSmarginmargin属性为给定元素设置四个方向的外边距属性 /* 应用于所有边 */margin: 1em;margin: -3px;/* 上边下边 | 左边右边 */margin: 5% auto;/* 上边 | 左边右边 | 下边 */margin: 1em auto 2em;/* 上边 | 右边 | 下边 | 左边 */margin: 2px 1em 0 auto;/* 全局值 */margin: inherit;margin: initial;margin: unset; auto可以在需要居中时使用。 box-sizing 在 CSS 盒子模型的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。 box-sizing 属性可以被用来调整这些表现： content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去 (border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 border-box不包含margin position各个取值:static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。 absolute 元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed 元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。(就像是固定在你的屏幕上了) sticky 元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见Github issue on W3C CSSWG）。 （也固定在你的屏幕上，但是当你滑动到这个东西的正常位置后，他就正常了） clear(清除浮动)clear CSS 属性指定一个元素是否必须移动 (清除浮动后) 到在它之前的浮动元素下面。clear 属性适用于浮动和非浮动元素。 注意是下面，已经指定好方位了。 值 none 元素不会被向下移动以清除浮动。 left 元素被向下移动以清除左浮动。 right 元素被向下移动以清除右浮动。 both 元素被向下移动以清除左右浮动。 inline-start 元素被向下移动以清除其包含块的起始侧浮动，即 ltr 时清除左浮动，rtl 时清除右浮动。 inline-end 元素被向下移动以清除其包含块的结束侧浮动，即 ltr 时清除右浮动，rtl 时清除左浮动。 JavaScriptJS的调用方式与执行顺序使用方式 HTML页面中的任意位置加上&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;标签即可。 常见使用方式有以下几种： 直接在&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;标签内写JS代码。直接引入文件：&lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt;。将所需的代码通过import关键字引入到当前作用域。例如： /static/js/index.js文件中的内容为： let name = &quot;acwing&quot;;function print() &#123; console.log(&quot;Hello World!&quot;);&#125;export &#123; name, print&#125; &lt;script type=&quot;module&quot;&gt;&lt;/script&gt;中的内容为: &lt;script type=&quot;module&quot;&gt; import &#123; name, print &#125; from &quot;/static/js/index.js&quot;; console.log(name); print();&lt;/script&gt; 执行顺序类似于HTML与CSS，按从上到下的顺序执行；事件驱动执行； HTML, CSS, JavaScript三者之间的关系CSS控制HTMLJavaScript控制HTML与CSS为了方便开发与维护，尽量按照上述顺序写代码。例如：不要在HTML中调用JavaScript中的函数。 script type=&quot;module&quot;限制变量的作用域 变量与运算符let与const 用来生命变量，作用范围为当前作用域。 let用来定义变量； const用来定义常量 例如： let s = &quot;acwing&quot;, x = 5;let d = &#123; name: &quot;yxc&quot;, age: 18,&#125;const n = 100; 变量类型 number：数值变量，例如1, 2.5 string：字符串，例如”acwing”, ‘yxc’，单引号与双引号均可。字符串中的每个字符为只读类型。 boolean：布尔值，例如true, false object：对象，类似于C++中的指针，例如[1, 2, 3]，{name: “yxc”, age: 18}，null undefined：未定义的变量 类似于Python，JavaScript中的变量类型可以动态变化。 运算符 与C++、Python、Java类似，不同点： **表示乘方 等于与不等于用&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D; parseInt(number)取整 输入与输出输入 从HTML与用户的交互中输入信息，例如通过input、textarea等标签获取用户的键盘输入，通过click、hover等事件获取用户的鼠标输入。 通过Ajax与WebSocket从服务器端获取输入 标准输入，参考AcWing 1. A + B 输出 调试用console.log，会将信息输出到浏览器控制台 改变当前页面的HTML与CSS 通过Ajax与WebSocket将结果返回到服务器 格式化字符串 字符串中填入数值: let name = &#x27;yxc&#x27;, age = 18;let s = `My name is $&#123;name&#125;, I&#x27;m $&#123;age&#125; years old.`; 定义多行字符串: let s = `&lt;div&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;段落&lt;/p&gt;/div&gt;` 保留两位小数如何输出: let x = 1.234567;let s = `$&#123;x.toFixed(2)&#125;`; let input = document.querySelector(&#x27;textarea&#x27;)let run = document.querySelector(&#x27;button&#x27;)let output = document.querySelector(&#x27;pre&#x27;)function main() &#123; run.addEventListener(&quot;click&quot;, function () &#123; /* 输入两个数，计算两个数的和 let [a, b] = input.value.split(&#x27; &#x27;); a = parseInt(a), b = parseInt(b); output.innerHTML = a + b; */ /* 输入一个小数，返回向0取整之后的结果 let a = parseFloat(input.value) output.innerHTML = parseInt(a) */ &#125;)&#125;export &#123; main&#125; 判断语句和C++一样。 循环语句感觉和C++一样 杂记Array.from()Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 console.log(Array.from(&#x27;foo&#x27;));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6] transitionend事件transitionend事件在CSS完成过渡后触发 例： keys.forEach(a =&gt; a.addEventListener(&#x27;transitionend&#x27;, removeTransition)) 类似于给一个标签添加了一个动画，在动画结束之后，也就是transition设定的时间结束之后，这个事件才开始执行。 setInterval()函数Window 和 Worker 接口提供的 setInterval() 方法重复调用一个函数或执行一个代码片段，在每次调用之间具有固定的时间间隔。 setInterval(setDate, 1000); transition-timing-functionCSS 属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个 transition 变化过程中，变化速度可以不断改变。 这条加速度曲线被&#96;&#96; (en-US)所定义，之后作用到每个 CSS 属性的过渡。 你可以规定多个 timing function，通过使用 transition-property属性，可以根据主列表 (transition property 的列表) 给每个 CSS 属性应用相应的 timing function.如果 timing function 的个数比主列表中数量少，缺少的值被设置为初始值（ease） 。如果 timing function 比主列表要多，timing function 函数列表会被截断至合适的大小。这两种情况下声明的 CSS 属性都是有效的。 .hand &#123; width: 50%; height: 6px; background-color: black; top: 50%; position: absolute; transform-origin: 100%; transform: rotate(90deg); transition: all .05s; transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);&#125; 结果是表盘的指针移动时会有振动的效果。 align-itemsCSS align-items 属性将所有直接子节点上的 align-self 值设置为一个组。align-self 属性设置项目在其包含块中在交叉轴方向上的对齐方式。 transform-origintransform-origin CSS 属性让你更改一个元素变形的原点。 类似于更改旋转的中心点，围绕哪个点旋转。 change当用户更改&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;元素的值并提交这个更改时，change 事件在这些元素上触发。和 input 事件不一样，change 事件并不是每次元素的 value 改变时都会触发。 text-aligntext-align CSS 属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。 text-align:center//常用于居中。 Array.prototype.reduce()reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。","categories":["程序","前端"]},{"title":"Hello World","path":"/2023/01/04/hello-world/","content":"Hello World!Hello My blog! Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"2023年一月新番","path":"/anime/2023_1_anime/2023年1月新番.html","content":"别当欧尼酱了 下载链接: 周四更新 更新至3集 智酱是女生 下载链接: 周三更新 更新至3集 阿鲁斯的巨兽 下载链接: 周六更新 更新至2集 不相信人类的冒险者接下来要去拯救世界 强烈推荐！！！人设非常好看！就是太穷了。。。 下载链接: 周二更新 更新至3集 转生王女与贵族千金的魔法革命 白河豚狂喜女主真的香，性格讨喜，单推！ 下载链接: 周三更新 更新至3集 尼尔:自动人形 便宜动画，无所谓了片尾1分钟的人偶戏才是精华其实正片还行 下载链接: 周六更新 更新至3集 邻家的天使大人 他们在整一种很甜的东西p9翻身之作（好吧并没有怎么翻身 下载链接: 周六更新 更新至3集 生而为狗，我很幸福 好怪哦再看一遍被阿里云ban了 下载链接: 周五更新 更新至2集 冰海战记 很棒的严肃向动画 下载链接: 周一更新 更新至2集 大雪海的凯纳 世界观很独特，音乐很牛逼 下载链接: 周三更新 更新至2集 因为太怕痛就全点防御力了 大脑寄存处 下载链接: 周三更新 更新至2集 久保同学不放过我 我将重回纯爱战神的行列，纯爱赛高！ 下载链接: 周三更新 更新至2集"}]